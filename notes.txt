CHAPTER 2:

Creating a Controller:

in <script>:
(previously defined:
var todoApp = angular.module("todoApp", []);
)

todoApp.controller("ToDoCtrl", function($scope){
	$scope.todo = model;
});

in <body>:
<body ng-controller="ToDoCtrl">

* $ used in built-in features of AngularJS; usually a service that provides features to multiple controllers
* $scope - used to expose data and functionality to views
* $scope.todo - defines a todo property on the $scope service object
* adding ng-controller attribute to the <body> tag means that the controller will be responsible for that entire section of HTML

Creating a View:

* can use data binding: double-braces {{...}}, e.g., todo.user, todo.items, ...
* access limited to $scope
* expressions can be used in data bindings ({{todo.items.length}}; avoid complicated expressions, put that logic in the controller instead

* ng-repeat (aka repeater) is a "directive" to iterate through a set of objects, e.g.:
				<tr ng-repeat="item in todo.items">
					<td>{{item.action}}</td>
					<td><input type="checkbox" ng-model="item.done" /></td>
					<td>{{item.done}}</td>
				</tr>
				
* ng-model provides two-way model binding: values changed by user are stored in the model:
 	<td><input type="checkbox" ng-model="item.done" /></td>
 
 Creating and Using Controller Behaviors:
 
 * behaviors - controller functions that operate on the data model to implement the business logic of the application
 * e.g., can calculate something for custom-display in the view (incompleteCount)
 * angular.forEach(list, [action]) - enumerator of elements in a list
 
 * ng-hide - one of directives to manipulate the browser DOM based on the state of AngulasJS model (hide the label if expr is true)
 
 * behaviors can depend on other behaviors (call them inside their body?)
 
 * ng-class - another AngularJS directive to apply CSS class to a control(?)
 * can use multiple directives in one <span> (e.g., ng-class, ng-hide)
  
Responding to User Interaction:

* via behaviors and directives
* ng-model directive can add a new (dynamic) property that has not been defined before, for user interaction
* ng-click sets up event handler (using behavior function) for click action

Filtering and Ordering Model Data:

Ex: <tr ng-repeat="item in todo.items | filter: {done: false} | orderBy: 'action'">
* filter: {criteria} - selects items for which criteria are met (e.g., {done: false})
* orderBy: property - order items by property values, ascending (if property is not defined by the scope, must use string literal: 'property')

* Better filtering: filter method of AngularJS model object
	- used to create a filter factory which returns a function that is used to filter a set of data objects.
	- aka, using the filter method requires passing in a function that returns a function that returns the filtered data

>> DON'T UNDERSTAND how the items are passed in with the syntax:
	<tr ng-repeat="item in todo.items | checkedItems:showComplete | orderBy: 'action'">

Getting the Data via Ajax:

* run - method defined in AngularJS module object; takes a function that is executed once AngularJS has performed its initial setup
* $http as argument - tells AngularJS to use the $http service (dependency injection)
* $http - service that provides access to low-level Ajax requests
* $http.get - method to make HTTP GET request (RESTful interface?) to the server for the JSON file
	$http.get("todo.json").success(function(data){
				model.items = data;
	});
	- get - returns a 'promise' - will come in the future when completed
	- [promise].success - takes a function invoked when request completed; data -> JSON stuff parsed and turned into a JavaScript object
	- that JS object ('data') is assigned to model.items

CHAPTER 3

* 2 kinds of Web applications: round-trip & single-page
* round-trip:
	- whole page submitted at once
	- user action would cause the page to fully reload (sent a completely new HTML doc)
	- logic and data reside on the server
	- still a lot of them around: require very little from browser -> widest client support
	- flaws:
		>> user waits while HTML doc requested & loaded
		>> large server infrastructure to process requests & manage state
		>> require a lot of bandwidth
* single-page:
	- initial HTML doc sent once to browser, never reloaded or replaced
	- user interactions cause Ajax requests for smaller HTML fragments or data
* AngularJs better suited for s-p applications, and complex r-t applications (jQuery good for r-t & simpler)
* jQuery:
	- explicitly manipulate browser's DOM
	- fluid API (?)
	- core library easy to extend
* AngularJS:
	- builds on the core functionality of jQuery (contains a cut-down version jqLite)
	- drawback: up-front investment before you see results
	- AngularJS is a client-side MVC framework	

Model (in MVC):
* data that users work with
* view models - represent just data passed from controller to view
* domain models - contain data in a business domain, with all operations, transformations and rules for CREATING, STORING & MANIPULATING that data (aka model logic)
* CRUD -> Create, Read, Updare & Delete operations

Controller (in MVC):
* conduit between model & view(s)
* adds business domain logic (aka 'behaviors') to model's 'scopes'
* able to initiate, present data from & update (based on user interactions) scope
* can create 'view data' (aka 'view model data' aka 'view models')
	- simplify the definition of views
	- non-persistent
	- usually created and accessed via controller's scope
	
View (in MVC):
* contain the logic & markup to present data to user
* should NOT contain complex logic (belongs in controller)
* should NOT contain logic that creates, stores or manipulates the domain model

RESTful Service:
* web service that provides CRUD functionality
* operations expressed through a combination of URL & HTTP method
* Methods:
	- GET - Retrieves the data object specified by the URL
	- PUT - Updates ...
	- POST - Creates a new data object
	- DELETE - Deletes ...
	
To avoid putting logic in the wrong place:
* View logic should prepare data only for display and never modify the model
* Controller logic should never directly create, update or delete data from the model
* The client should never directly access the data store
 
CHAPTER 4
HTML and Bootstrap CSS Primer

HTML Document Structure:
<!DOCTYPE html>
<html>
	<head>
		... head content (metadata)
	</head>
	<body>
		... body content
	</body>
</html>

Other elements:

button - button, for user interaction
div - generic element; adds structure
h1 - top-level header
input - field to get a single data item from user
link - imports content to html
	ex: <link href="bootstrap.css" rel="stylesheet" />
	attributes: href - content to import, rel - content type
script - script to be executed as part of the document (typically JS)
span - generic element; adds structure
style - region of CSS settings
table - table (rows & columns)
tbody - table body
td - table data (cell)
th - header cell in a table row
thead - table header
tr - table row
title - document title, used for window/tab title in the browser

BOOTSTRAP
Basic Bootstrap Classes:

panel - panel with a rounded border. Can have header and footer.
panel-heading - heading for a panel
btn - button
	ex: <button class="btn">Basic Button</button>
well - groups elements with an inset effect

Content & Size Classes (used with basic class, e.g., btn)

* btn-primary, btn-success, btn-warning, btn-info, btn-danger
* btn-large, btn-small
* btn-block - fits available horizontal space
ex: <button class="btn btn-block btn-warning">Standard Block Warning</button>

Table Styles:

table - basic table styling
table-striped - alternate row striping
table-hover - different row style when a mouse hovers over a row
table-condensed - reduced spacing (more compact layout)

* content styling can be applied to rows or even cells:
	<tr class="success"><td>United Kingdom</td><td>London</td></tr>
	<tr class="danger"><td>France</td><td>Paris</td></tr>
	<tr><td>Spain</td><td class="warning">Madrid</td></tr>

Forms in Bootstrap:

* form-group - groups elements together, e.g., label & input box (form-control):
	<div class="form-group">
		<label>Name:</label>
		<input name="name" class="form-control" />
	</div>
* form-control - input field like a textbox
* radio - radio button (not sure if this is Bootstrap or generic)
	ex: <div class="radio">
			<label>
				<input type="radio" name="junkmail" value="yes" checked />
				Yes, send me endless junk mail
			</label>
		</div>
		<div class="radio">
			<label>
				<input type="radio" name="junkmail" value="no" />
				No, I never want to hear from you again
			</label>
		</div>
	Q: Does the same name ("junkmail") put them in the same group and mutually exclusive?
* checkbox - checkbox (not sure if this is Bootstrap or generic)
	ex: <div class="checkbox">
			<label>
				<input type="checkbox" />
				I agree to terms and conditions.
			</label>
		</div>
		
Grids in Bootstrap:

* based on 12-column rows
* assign "width" to columns like this: <div class="col-xs-1">column content</div>
* ex:
		<div id="gridContainer">
			<div class="row grid-row">
				<div class="col-xs-12">aaa</div>
			</div>
			<div class="row grid-row">
				<div class="col-xs-6">bbb</div>
				<div class="col-xs-6">ccc</div>
			</div>
		</div>
* sometimes grids impossible to render properly in browser (if no support for CSS3); then ok to use tables.

Responsive Grids:

* stack grid cells vertically if screen width < xxx pxls.
* use these Bootstrap classes:
	- col-sm-* - vert if screen width <= 768 px
	- col-md-* - 940 px
	- col-lg-* - 1170 px
* need a "meta" tag to tell mobile browsers to display the content actual size:
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
CHAPTER 5
JS primer

* angular.isFunction(obj) - checks if ob is a function
	angular is a global object created automatically when angular.js is added to HTML:
	<script src="angular.js"></script>

* vars declared in script (not inside a function) are global and can be accessed anywhere, including other scripts within the same HTML doc.
	- don't use global vars!

* AngularJS utility methods for string:
	- angular.isString(object)
	- angular.lowercase(string)
	- angular.uppercase(string)

* Creating objects:
	- with 'new':
		var obj = new Object();
		obj.name = "Adam";
		obj.weather = "sunny";
		
	- with object litersl:
		var obj = {
			name: "Adam",
			weather: "sunny"
		};
	-> object properties can be added AFTER object is created!
	-> accessing properties:
		- obj.name, obj.weather
		- obj["name"], obj["weather"]
		- var prop = "weather"; obj[prop] = ...
	-> checking for properties - use 'in':
		var hasName = "name" in obj; 

* Adding functions to objects:
	var obj = {
		name: "Adam",
		weather: "sunny",
		printMessages: function(){
			console.log("Hello " + this.name + ".");
			console.log("Today is " + this.weather + ".");
		};
	};
	obj.printMessages();
	-> to access object's properties from within a function, use 'this.'!
	
* Extending objects:
	copies all the 'base' object's properties to the extended object
	var obj = {
		name: "Adam",
		weather: "sunny",
		printMessages: function(){
			console.log("Hello " + this.name + ".");
			console.log("Today is " + this.weather + ".");
		};
	};
	var extObj = {
		city: "London"
	};
	angular.extend(extObj, obj);	// now extObj has name, weather and printMessages, too!
	-> angular.extend preserves all properties and methods of the target object (extObj)
	-> angular.copy creates a copy of original object (obj) without preserving target's props
	
* Detecting objects: angular.isObject(arg)
	-> returns false for functions
	
* Enumerating properties:
	for (var prop in obj){
		console.log("Name: " + prop + " Value: " + obj[prop]);
	}
	
	or, with AngularJS:
	angular.foreach(obj, function(value, key){
		console.log("Name: " + key + " Value: " + value); 
	});
	-> will produce the same result!
	-> will include functions in a=enumeration!

* Adding/deleting object properties:
	- add - just use it:
	obj.newProp = "aaa";
	(or obj["newProp"] = "aaa";
	obj.sanHello = function(){
		console.write("Hello");
	};
	- delete - use 'delete':
	delete obj.newProp;
	delete obj["name"];
	delete obj.sayHello;
	
* string concatenation (+) has higher precedence than addition (+):
	var one = 5 + 5;	-> 10
	var two = 5 + "5";	-> 55
	
* Converting numbers to strings:
	- (5).toString()	-> base 10
	- String(5)
	Also these are available:
	- toString(2), toString(8),...
	- toFixed(n)	- real number with n decimal digits
	- toExponential(n) - number in exp form, 1 digit before the decimal point & n digits after
	- toPrecision(n) - number with n significant digits, using exp notation if needed

* Converting strings to numbers:
	- Number(str)
	- parseInt(str)
	- parseFloat(str)
	
* Arrays:
	- create:	var arr = new Array();// or var arr = [];
				arr[0] = 100;
				arr[1] = "aaa";
				arr[2] = false;
		or use array literal:
			var arr = [100, "aaa", false];
	- detect: angular.isArray(arg)
	- enumerating:
		for (var i=0; i < arr.length; i++){
			console.log("Index: " + i + ": " + arr[i]);
		}
		OR:
		angular.foreach(arr, function(value, key){
			console.log(key + ": " + value);
		});
		-> in this case, key is not necessaily an "index", e.g., if the array has holes (?)
	- built-in methods:
		> concat(anotherArray) returns concatenated Array
		> join(separator) returns string of separator-delimited array elements
		> pop() removes last item from array and returns it
		> push(item) appends item to array
		> reverse() reverses the array (in place!)
		> shift() removes first object from array and returns it
		> slice(start,end) returns a section of array
			start, end indexed from 0;
			start included, end excluded
		> sort() (in place!)
		> splice(index,count) removes count items from array, starting at index
		> upshift(item) inserts item at the start of array

* null & undefined:
	- not the same (undefined is a type, null is a value)
	- both falsy 
	- checking if something is null or undefined (don't care which):
		if (!obj.prop)
	- for undefined -> angular.isDefined / angular.isUndefined

* Promises:
	- promise - represents an item of work that will be performed asynchronously and completed in the future
	- most common - when making Ajax requests
	- promise is used to notify the application when the request has completed
	- 	var promise = $http.get("todo.json");
		promise.success(function(data){
			$scope.todos = data;
		});
	- promise object has 3 methods:
		> success(callback) - callback invoked when work was successful; receives returned data
		> error(callback) - callback invoked when work could not be completed; receives problem details
		> then(success, error) - callbacks for success and failure
		
* JSON (JavaScript Object Notation)
	- data format for web apps
	- supported types: String, Nymber, Boolean, ARray, Object, null
	- AngularJS support: angular.toJson, angular.fromJson
	- ex:	var myApp = angular.module("demo", []);
			myApp.controller("demoCtrl", function($scope, $http){
				var jsonStr = angular.toJson(data);
				console.log(jsonStr);
				$scope.todos = angular.fromJson(jsonStr);
			});

CHAPTER 9
The Anatomy of an AngularJS App

* AngularJS apps follow MVC pattern (model/view/controller are the main building blocks)
* but, there are many components:
	- modules
	- directives
	- filters
	- factories
	- services
	
* When to use components:
	- create AngJS module				angular.module method
	- set scope of module				ng-app attribute
	- define controller					Module.controller method
	- apply controller to view			ng-controller attribute
	- pass data from ctrl to view		$scope service
	- define directive					Module.directive method
	- define filter						Module.filter method
	- use filter programmatically		$filter service
	- define service					Module.service, Module.factory or Module.provider method
	- define service from existing obj or val		Module.value method
	- add strusture to code in app		create mult modules & declare dependencies from the module referenced by ng-app attribute
	- register functions called when module loaded	Module.config, Module.run methods

* Modules
	- top-level components
	- to create, in JavaSctipt (<script>) call: 
		angular.module(name, requires, config)
		> name - module name
		> requires - list of modules that the created module depends on
		> config - configuraion of the module (equivalent to Module.config method); optional?
	- must apply the module to HTML content with ng-app directive, usually here:
		<html ng-app="exampleApp">
	- Module members:
		> animation(name, factory			supports animation feature (?)
		> config(callback)					registers fn to configure module when it's loaded
		> constant(key, value)				defines service that returns constant value
		> controller(name, constructor)		creates controller
		> directive(name, factory)			creates directive, to extend standard HTML
		> factory(name, provider)			creates service
		> filter(name, factory)				creates filter do format data for display
		> provider(name, type)				creates service
		> name								returns module name
		> run(callback)						registers fn invoked after AngularJS has loaded and config'd all modules
		> service(name, constructor)		creates service
		> value(name, value)				defines service that returns constant value
		
* Controllers
	- to create: call:
		Module.controller(name, constructor)
		> name - controller name
		> constructor - factory function to set up controller's actions;
			also: used to declare controller's dependencies (Dependency Injection)
		ex: myApp.controller("dayCtrl", function($scope){
    			// controller stuff
    		});
    	this controller depends on $scope component
    - must be applied to HTML elements with ng-controller directive:
    	<div class="panel" ng-controller="dayCtrl">
    	...
    	</div>
    	Only data defined in the controller's $scope can be used inside the <div> block (which defines the 'view')
    - can be applied to multiple views if desired	
    	
* Dependency Injection (DI)
 	changes the purpose of fn arguments:
 		- without DI, args 'receive" objects passed by caller; 
 		- with DI, the fn uses args to demand stuff -> tell AngularJS what it needs
 		
* Fluent API: multiple calls to methodc are "chained" together:
 	<script>
 		angular.module("exampleApp", [])
 			.controller("ctrl1", function($scope){
 				...
 			})
 			.controller("ctrl2", function($scope){
 				...
 			})
 			.directive("dir1", function(){
 				...
 			});
 	</script>
 	
* Directives
 	- extend & enhance HTML
 	- to create, call:
 		Module.directive(name, factory)
 		> name - directive name
 		> factory fn (often returns a 'worker' fn, as in this example:
	 		myApp.directive("highlight", function(){		// factory
	    		return function(scope, element, attrs){		// worker
	    			if (scope.day == attrs["highlight"]){
	    				element.css("color", "red");
	    			}
	    		}
	    	});
	    (there are other ways)
	- applied as attribute:
		<h4 ng-controller="dayCtrl" highlight="Thursday">
		(there are other ways)
	
* Filters
 	- used in views to format data displayed to user
 	- to create, call:
 		Module.filter(name, factory)
 	- applied in template expressions in views (data binding expr): bar (|) followed by filter name
 		Today is {{day || "(unknown)" | dayName}}
 		day or "unknown" are passed as input to the 'dayName' filter
 
* Services
 	- singleton objects that provide custom functionality throughout application
 	- examples of built-in services: $scope, $filter
 	- created with service, factory or provider methods of Module object
 		myApp.service("days", function(){
    		this.today = new Date().getDay();
    		this.tomorrow = this.today + 1;
    	});
  
* Defining Values
  	- Module.value method:
  		var now = new Date();
  		myApp.value("nowValue", now);
  	- can be used as Data Injection:
  		myApp.service("days", function(nowValue) {...
 	- odd but useful?
 	
* Using Modules to Organize Code
 	- good way to divide functionality
 	- need to put "helper" modules in the dependency list ([]) of main module
 	- order not importand, AngularJS will resolve the dependencies properly
 	- can be defined in separate .js files and included with <script src="filename"></script>, OR
 		in the same file as the main application module
 	
* Module Life Cycle
	- Module.config: arg is a function invoked after the module has been loaded
 	- Module.run: arg is a function invoked after ALL modules have been loaded
 	- ex: 	.config(function(){
 				console.log("Config called");
 			})
 			.run(function(){
 				console.log("Run called");
 			});
 	- any module can have these (main and sub)
 		> subs' config will execute before main's config;
 		> subs' run will execute after all configs but before main's run
 		(generally, in order of loading)
 		
 CHAPTER 10
 Using Binding & Template Directives
 
* Directives:
	- AngularJS most powerful feature
	- extend HTML to create rich & complex web applications
 
* Commonly used directives:
 - create one-way binding					define properties on $scope, use ng-bind, ng-bind-template directive, or inline {{...}}
 - prevent processing of inline binding		ng-non-bindable
 - create two-way binding					ng-model
 - generate repeated elements				ng-repeat
 - get context info on ng-repeat's current object	use built-in variables like $first, $last
 - read multiple top-level attributes		ng-repeat-start, ng-repeat-end
 - load partial view						ng-include
 - conditionally display elements			ng-switch
 - hide inline telmplate expr while AngJS is processing content (???)	ng-cloak
 
* Data Binding Directives
 (All can be applies as attribute or class)
 ng-bind			binds innerText property of HTML element
 ng-bind-html		binds innerHTML property of HTML element (can be dangerous?)
 ng-bind-template	same as ng-bind but allows for mult template expressions in the attribute value (?)
 ng-model			creates two-way data binding (applicable to input, textarea & select elements)
 nd-non-bindable	declares region where no data binding will be performed
 
	Applying as attribute:
 	There are <span ng-bind="todos.length"></span> items
 	Applying as class:
 	There are <span class="ng-bind: todos.length"></span> items

* Template Directives
 	Used to generate HTML elements using templates, good for working with collectoins
 (Application: A - attribute, C - class, E - element)
 ng-cloak			A,C		applies CSS style that hides inline binging expressions
 ng-include			E,A,C	loads, processes and inserts an HTML fragment into the DOM
 ng-repeat			A,C		generates copies of single element for each object in array or properto on object
 ng-repeat-start	A,C		start of repeating section with multiple top-level elements
 ng-end				A,C		end of repeating section with multiple top-level elements
 ng-switch			E,A		changes elements in the DOM based on value of data bindings
 
* ng-repeat
 - ng-repeat can be used to iterate through items in array, or properties in object
 - ng-repeat can also work with key/value pairs (props: propname/propvalue, arrays: index/value)
 	<tr ng-repeat="item in collection">
 		<td ng-repeat=(key,value) in item">
 			{{key}}={{value}}
 		</td>
 	</tr>
 - has built-in variables:
 $index		position of current item or property
 $first		true if current item is first in collection
 $middle	true if current item is neither first nor last in collection
 $last		true if current item is last in collection
 $even		true for even-numbered items in collection
 $odd		true for odd-numbered items in collection
 
* ng-repeat-start and ng-repeat-end
  - allow for multiple top-level elements to be repeated for each item in collection, e.g., table rows <tr>
  - the start and end directives act like opening and closing braces that enclose all elements to be generated for a single item
 
* ng-include
  - adds content from a separate HTML file to the main file's DOM
  - useful for partial views
  - 3 configuration params:
  	src			src="'filename'"	<- notice single quotes inside double quotes!
  	onload		expression to evaluate when content is loaded
  	autoscroll	scroll the viewport when content is loaded

	ex: as element:
		<ng-include src="viewFile()" onload="reportChange()"></ng-include>
		as attribute:
		<div ng-include="viewFile()" onload="reportChange()"></div> 	

* ng-switch
  - allows for conditionally displaying partial views for multiple cases
    ex: <div ng-switch on="data.mode">
			<div ng-switch-when="Table">
				<ng-include src="'views/table.html'"></ng-include>
			</div>
			<div ng-switch-when="List">
				<ng-include src="'views/list.html'"></ng-include>
			</div>
			<div ng-switch-default>
				Select table or list to display data 
			</div>
		</div>
		
* ng-cloak
  - used as attribute for elements that have inline bingdings, to prevent {{...}} from showing on screen when content is loaded
  - not a problem on fast browsers 