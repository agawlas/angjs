CHAPTER 2:

Creating a Controller:

in <script>:
(previously defined:
var todoApp = angular.module("todoApp", []);
)

todoApp.controller("ToDoCtrl", function($scope){
	$scope.todo = model;
});

in <body>:
<body ng-controller="ToDoCtrl">

* $ used in built-in features of AngularJS; usually a service that provides features to multiple controllers
* $scope - used to expose data and functionality to views
* $scope.todo - defines a todo property on the $scope service object
* adding ng-controller attribute to the <body> tag means that the controller will be responsible for that entire section of HTML

Creating a View:

* can use data binding: double-braces {{...}}, e.g., todo.user, todo.items, ...
* access limited to $scope
* expressions can be used in data bindings ({{todo.items.length}}; avoid complicated expressions, put that logic in the controller instead

* ng-repeat (aka repeater) is a "directive" to iterate through a set of objects, e.g.:
				<tr ng-repeat="item in todo.items">
					<td>{{item.action}}</td>
					<td><input type="checkbox" ng-model="item.done" /></td>
					<td>{{item.done}}</td>
				</tr>
				
* ng-model provides two-way model binding: values changed by user are stored in the model:
 	<td><input type="checkbox" ng-model="item.done" /></td>
 
 Creating and Using Controller Behaviors:
 
 * behaviors - controller functions that operate on the data model to implement the business logic of the application
 * e.g., can calculate something for custom-display in the view (incompleteCount)
 * angular.forEach(list, [action]) - enumerator of elements in a list
 
 * ng-hide - one of directives to manipulate the browser DOM based on the state of AngulasJS model (hide the label if expr is true)
 
 * behaviors can depend on other behaviors (call them inside their body?)
 
 * ng-class - another AngularJS directive to apply CSS class to a control(?)
 * can use multiple directives in one <span> (e.g., ng-class, ng-hide)
  
Responding to User Interaction:

* via behaviors and directives
* ng-model directive can add a new (dynamic) property that has not been defined before, for user interaction
* ng-click sets up event handler (using behavior function) for click action

Filtering and Ordering Model Data:

Ex: <tr ng-repeat="item in todo.items | filter: {done: false} | orderBy: 'action'">
* filter: {criteria} - selects items for which criteria are met (e.g., {done: false})
* orderBy: property - order items by property values, ascending (if property is not defined by the scope, must use string literal: 'property')

* Better filtering: filter method of AngularJS model object
	- used to create a filter factory which returns a function that is used to filter a set of data objects.
	- aka, using the filter method requires passing in a function that returns a function that returns the filtered data

>> DON'T UNDERSTAND how the items are passed in with the syntax:
	<tr ng-repeat="item in todo.items | checkedItems:showComplete | orderBy: 'action'">

Getting the Data via Ajax:

* run - method defined in AngularJS module object; takes a function that is executed once AngularJS has performed its initial setup
* $http as argument - tells AngularJS to use the $http service (dependency injection)
* $http - service that provides access to low-level Ajax requests
* $http.get - method to make HTTP GET request (RESTful interface?) to the server for the JSON file
	$http.get("todo.json").success(function(data){
				model.items = data;
	});
	- get - returns a 'promise' - will come in the future when completed
	- [promise].success - takes a function invoked when request completed; data -> JSON stuff parsed and turned into a JavaScript object
	- that JS object ('data') is assigned to model.items

CHAPTER 3

* 2 kinds of Web applications: round-trip & single-page
* round-trip:
	- whole page submitted at once
	- user action would cause the page to fully reload (sent a completely new HTML doc)
	- logic and data reside on the server
	- still a lot of them around: require very little from browser -> widest client support
	- flaws:
		>> user waits while HTML doc requested & loaded
		>> large server infrastructure to process requests & manage state
		>> require a lot of bandwidth
* single-page:
	- initial HTML doc sent once to browser, never reloaded or replaced
	- user interactions cause Ajax requests for smaller HTML fragments or data
* AngularJs better suited for s-p applications, and complex r-t applications (jQuery good for r-t & simpler)
* jQuery:
	- explicitly manipulate browser's DOM
	- fluid API (?)
	- core library easy to extend
* AngularJS:
	- builds on the core functionality of jQuery (contains a cut-down version jqLite)
	- drawback: up-front investment before you see results
	- AngularJS is a client-side MVC framework	

Model (in MVC):
* data that users work with
* view models - represent just data passed from controller to view
* domain models - contain data in a business domain, with all operations, transformations and rules for CREATING, STORING & MANIPULATING that data (aka model logic)
* CRUD -> Create, Read, Updare & Delete operations

Controller (in MVC):
* conduit between model & view(s)
* adds business domain logic (aka 'behaviors') to model's 'scopes'
* able to initiate, present data from & update (based on user interactions) scope
* can create 'view data' (aka 'view model data' aka 'view models')
	- simplify the definition of views
	- non-persistent
	- usually created and accessed via controller's scope
	
View (in MVC):
* contain the logic & markup to present data to user
* should NOT contain complex logic (belongs in controller)
* should NOT contain logic that creates, stores or manipulates the domain model

RESTful Service:
* web service that provides CRUD functionality
* operations expressed through a combination of URL & HTTP method
* Methods:
	- GET - Retrieves the data object specified by the URL
	- PUT - Updates ...
	- POST - Creates a new data object
	- DELETE - Deletes ...
	
To avoid putting logic in the wrong place:
* View logic should prepare data only for display and never modify the model
* Controller logic should never directly create, update or delete data from the model
* The client should never directly access the data store
 
CHAPTER 4
HTML and Bootstrap CSS Primer

HTML Document Structure:
<!DOCTYPE html>
<html>
	<head>
		... head content (metadata)
	</head>
	<body>
		... body content
	</body>
</html>

Other elements:

button - button, for user interaction
div - generic element; adds structure
h1 - top-level header
input - field to get a single data item from user
link - imports content to html
	ex: <link href="bootstrap.css" rel="stylesheet" />
	attributes: href - content to import, rel - content type
script - script to be executed as part of the document (typically JS)
span - generic element; adds structure
style - region of CSS settings
table - table (rows & columns)
tbody - table body
td - table data (cell)
th - header cell in a table row
thead - table header
tr - table row
title - document title, used for window/tab title in the browser

BOOTSTRAP
Basic Bootstrap Classes:

panel - panel with a rounded border. Can have header and footer.
panel-heading - heading for a panel
btn - button
	ex: <button class="btn">Basic Button</button>
well - groups elements with an inset effect

Content & Size Classes (used with basic class, e.g., btn)

* btn-primary, btn-success, btn-warning, btn-info, btn-danger
* btn-large, btn-small
* btn-block - fits available horizontal space
ex: <button class="btn btn-block btn-warning">Standard Block Warning</button>

Table Styles:

table - basic table styling
table-striped - alternate row striping
table-hover - different row style when a mouse hovers over a row
table-condensed - reduced spacing (more compact layout)

* content styling can be applied to rows or even cells:
	<tr class="success"><td>United Kingdom</td><td>London</td></tr>
	<tr class="danger"><td>France</td><td>Paris</td></tr>
	<tr><td>Spain</td><td class="warning">Madrid</td></tr>

Forms in Bootstrap:

* form-group - groups elements together, e.g., label & input box (form-control):
	<div class="form-group">
		<label>Name:</label>
		<input name="name" class="form-control" />
	</div>
* form-control - input field like a textbox
* radio - radio button (not sure if this is Bootstrap or generic)
	ex: <div class="radio">
			<label>
				<input type="radio" name="junkmail" value="yes" checked />
				Yes, send me endless junk mail
			</label>
		</div>
		<div class="radio">
			<label>
				<input type="radio" name="junkmail" value="no" />
				No, I never want to hear from you again
			</label>
		</div>
	Q: Does the same name ("junkmail") put them in the same group and mutually exclusive?
* checkbox - checkbox (not sure if this is Bootstrap or generic)
	ex: <div class="checkbox">
			<label>
				<input type="checkbox" />
				I agree to terms and conditions.
			</label>
		</div>
		
Grids in Bootstrap:

* based on 12-column rows
* assign "width" to columns like this: <div class="col-xs-1">column content</div>
* ex:
		<div id="gridContainer">
			<div class="row grid-row">
				<div class="col-xs-12">aaa</div>
			</div>
			<div class="row grid-row">
				<div class="col-xs-6">bbb</div>
				<div class="col-xs-6">ccc</div>
			</div>
		</div>
* sometimes grids impossible to render properly in browser (if no support for CSS3); then ok to use tables.

Responsive Grids:

* stack grid cells vertically if screen width < xxx pxls.
* use these Bootstrap classes:
	- col-sm-* - vert if screen width <= 768 px
	- col-md-* - 940 px
	- col-lg-* - 1170 px
* need a "meta" tag to tell mobile browsers to display the content actual size:
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
CHAPTER 5
JS primer

* angular.isFunction(obj) - checks if ob is a function
	angular is a global object created automatically when angular.js is added to HTML:
	<script src="angular.js"></script>

* vars declared in script (not inside a function) are global and can be accessed anywhere, including other scripts within the same HTML doc.
	- don't use global vars!

* AngularJS utility methods for string:
	- angular.isString(object)
	- angular.lowercase(string)
	- angular.uppercase(string)

* Creating objects:
	- with 'new':
		var obj = new Object();
		obj.name = "Adam";
		obj.weather = "sunny";
		
	- with object litersl:
		var obj = {
			name: "Adam",
			weather: "sunny"
		};
	-> object properties can be added AFTER object is created!
	-> accessing properties:
		- obj.name, obj.weather
		- obj["name"], obj["weather"]
		- var prop = "weather"; obj[prop] = ...
	-> checking for properties - use 'in':
		var hasName = "name" in obj; 

* Adding functions to objects:
	var obj = {
		name: "Adam",
		weather: "sunny",
		printMessages: function(){
			console.log("Hello " + this.name + ".");
			console.log("Today is " + this.weather + ".");
		};
	};
	obj.printMessages();
	-> to access object's properties from within a function, use 'this.'!
	
* Extending objects:
	copies all the 'base' object's properties to the extended object
	var obj = {
		name: "Adam",
		weather: "sunny",
		printMessages: function(){
			console.log("Hello " + this.name + ".");
			console.log("Today is " + this.weather + ".");
		};
	};
	var extObj = {
		city: "London"
	};
	angular.extend(extObj, obj);	// now extObj has name, weather and printMessages, too!
	-> angular.extend preserves all properties and methods of the target object (extObj)
	-> angular.copy creates a copy of original object (obj) without preserving target's props
	
* Detecting objects: angular.isObject(arg)
	-> returns false for functions
	
* Enumerating properties:
	for (var prop in obj){
		console.log("Name: " + prop + " Value: " + obj[prop]);
	}
	
	or, with AngularJS:
	angular.foreach(obj, function(value, key){
		console.log("Name: " + key + " Value: " + value); 
	});
	-> will produce the same result!
	-> will include functions in a=enumeration!

* Adding/deleting object properties:
	- add - just use it:
	obj.newProp = "aaa";
	(or obj["newProp"] = "aaa";
	obj.sanHello = function(){
		console.write("Hello");
	};
	- delete - use 'delete':
	delete obj.newProp;
	delete obj["name"];
	delete obj.sayHello;
	
* string concatenation (+) has higher precedence than addition (+):
	var one = 5 + 5;	-> 10
	var two = 5 + "5";	-> 55
	
* Converting numbers to strings:
	- (5).toString()	-> base 10
	- String(5)
	Also these are available:
	- toString(2), toString(8),...
	- toFixed(n)	- real number with n decimal digits
	- toExponential(n) - number in exp form, 1 digit before the decimal point & n digits after
	- toPrecision(n) - number with n significant digits, using exp notation if needed

* Converting strings to numbers:
	- Number(str)
	- parseInt(str)
	- parseFloat(str)
	
* Arrays:
	- create:	var arr = new Array();// or var arr = [];
				arr[0] = 100;
				arr[1] = "aaa";
				arr[2] = false;
		or use array literal:
			var arr = [100, "aaa", false];
	- detect: angular.isArray(arg)
	- enumerating:
		for (var i=0; i < arr.length; i++){
			console.log("Index: " + i + ": " + arr[i]);
		}
		OR:
		angular.foreach(arr, function(value, key){
			console.log(key + ": " + value);
		});
		-> in this case, key is not necessaily an "index", e.g., if the array has holes (?)
	- built-in methods:
		> concat(anotherArray) returns concatenated Array
		> join(separator) returns string of separator-delimited array elements
		> pop() removes last item from array and returns it
		> push(item) appends item to array
		> reverse() reverses the array (in place!)
		> shift() removes first object from array and returns it
		> slice(start,end) returns a section of array
			start, end indexed from 0;
			start included, end excluded
		> sort() (in place!)
		> splice(index,count) removes count items from array, starting at index
		> upshift(item) inserts item at the start of array

* null & undefined:
	- not the same (undefined is a type, null is a value)
	- both falsy 
	- checking if something is null or undefined (don't care which):
		if (!obj.prop)
	- for undefined -> angular.isDefined / angular.isUndefined

* Promises:
	- promise - represents an item of work that will be performed asynchronously and completed in the future
	- most common - when making Ajax requests
	- promise is used to notify the application when the request has completed
	- 	var promise = $http.get("todo.json");
		promise.success(function(data){
			$scope.todos = data;
		});
	- promise object has 3 methods:
		> success(callback) - callback invoked when work was successful; receives returned data
		> error(callback) - callback invoked when work could not be completed; receives problem details
		> then(success, error) - callbacks for success and failure
		
* JSON (JavaScript Object Notation)
	- data format for web apps
	- supported types: String, Nymber, Boolean, ARray, Object, null
	- AngularJS support: angular.toJson, angular.fromJson
	- ex:	var myApp = angular.module("demo", []);
			myApp.controller("demoCtrl", function($scope, $http){
				var jsonStr = angular.toJson(data);
				console.log(jsonStr);
				$scope.todos = angular.fromJson(jsonStr);
			});

CHAPTER 9
The Anatomy of an AngularJS App

* AngularJS apps follow MVC pattern (model/view/controller are the main building blocks)
* but, there are many components:
	- modules
	- directives
	- filters
	- factories
	- services
	
* When to use components:
	- create AngJS module				angular.module method
	- set scope of module				ng-app attribute
	- define controller					Module.controller method
	- apply controller to view			ng-controller attribute
	- pass data from ctrl to view		$scope service
	- define directive					Module.directive method
	- define filter						Module.filter method
	- use filter programmatically		$filter service
	- define service					Module.service, Module.factory or Module.provider method
	- define service from existing obj or val		Module.value method
	- add strusture to code in app		create mult modules & declare dependencies from the module referenced by ng-app attribute
	- register functions called when module loaded	Module.config, Module.run methods

* Modules
	- top-level components
	- to create, in JavaSctipt (<script>) call: 
		angular.module(name, requires, config)
		> name - module name
		> requires - list of modules that the created module depends on
		> config - configuraion of the module (equivalent to Module.config method); optional?
	- must apply the module to HTML content with ng-app directive, usually here:
		<html ng-app="exampleApp">
	- Module members:
		> animation(name, factory			supports animation feature (?)
		> config(callback)					registers fn to configure module when it's loaded
		> constant(key, value)				defines service that returns constant value
		> controller(name, constructor)		creates controller
		> directive(name, factory)			creates directive, to extend standard HTML
		> factory(name, provider)			creates service
		> filter(name, factory)				creates filter do format data for display
		> provider(name, type)				creates service
		> name								returns module name
		> run(callback)						registers fn invoked after AngularJS has loaded and config'd all modules
		> service(name, constructor)		creates service
		> value(name, value)				defines service that returns constant value
		
* Controllers
	- to create: call:
		Module.controller(name, constructor)
		> name - controller name
		> constructor - factory function to set up controller's actions;
			also: used to declare controller's dependencies (Dependency Injection)
		ex: myApp.controller("dayCtrl", function($scope){
    			// controller stuff
    		});
    	this controller depends on $scope component
    - must be applied to HTML elements with ng-controller directive:
    	<div class="panel" ng-controller="dayCtrl">
    	...
    	</div>
    	Only data defined in the controller's $scope can be used inside the <div> block (which defines the 'view')
    - can be applied to multiple views if desired	
    	
* Dependency Injection (DI)
 	changes the purpose of fn arguments:
 		- without DI, args 'receive" objects passed by caller; 
 		- with DI, the fn uses args to demand stuff -> tell AngularJS what it needs
 		
* Fluent API: multiple calls to methodc are "chained" together:
 	<script>
 		angular.module("exampleApp", [])
 			.controller("ctrl1", function($scope){
 				...
 			})
 			.controller("ctrl2", function($scope){
 				...
 			})
 			.directive("dir1", function(){
 				...
 			});
 	</script>
 	
* Directives
 	- extend & enhance HTML
 	- to create, call:
 		Module.directive(name, factory)
 		> name - directive name
 		> factory fn (often returns a 'worker' fn, as in this example:
	 		myApp.directive("highlight", function(){		// factory
	    		return function(scope, element, attrs){		// worker
	    			if (scope.day == attrs["highlight"]){
	    				element.css("color", "red");
	    			}
	    		}
	    	});
	    (there are other ways)
	- applied as attribute:
		<h4 ng-controller="dayCtrl" highlight="Thursday">
		(there are other ways)
	
* Filters
 	- used in views to format data displayed to user
 	- to create, call:
 		Module.filter(name, factory)
 	- applied in template expressions in views (data binding expr): bar (|) followed by filter name
 		Today is {{day || "(unknown)" | dayName}}
 		day or "unknown" are passed as input to the 'dayName' filter
 
* Services
 	- singleton objects that provide custom functionality throughout application
 	- examples of built-in services: $scope, $filter
 	- created with service, factory or provider methods of Module object
 		myApp.service("days", function(){
    		this.today = new Date().getDay();
    		this.tomorrow = this.today + 1;
    	});
  
* Defining Values
  	- Module.value method:
  		var now = new Date();
  		myApp.value("nowValue", now);
  	- can be used as Data Injection:
  		myApp.service("days", function(nowValue) {...
 	- odd but useful?
 	
* Using Modules to Organize Code
 	- good way to divide functionality
 	- need to put "helper" modules in the dependency list ([]) of main module
 	- order not importand, AngularJS will resolve the dependencies properly
 	- can be defined in separate .js files and included with <script src="filename"></script>, OR
 		in the same file as the main application module
 	
* Module Life Cycle
	- Module.config: arg is a function invoked after the module has been loaded
 	- Module.run: arg is a function invoked after ALL modules have been loaded
 	- ex: 	.config(function(){
 				console.log("Config called");
 			})
 			.run(function(){
 				console.log("Run called");
 			});
 	- any module can have these (main and sub)
 		> subs' config will execute before main's config;
 		> subs' run will execute after all configs but before main's run
 		(generally, in order of loading)
 		
 CHAPTER 10
 Using Binding & Template Directives
 
* Directives:
	- AngularJS most powerful feature
	- extend HTML to create rich & complex web applications
 
* Commonly used directives:
 - create one-way binding					define properties on $scope, use ng-bind, ng-bind-template directive, or inline {{...}}
 - prevent processing of inline binding		ng-non-bindable
 - create two-way binding					ng-model
 - generate repeated elements				ng-repeat
 - get context info on ng-repeat's current object	use built-in variables like $first, $last
 - read multiple top-level attributes		ng-repeat-start, ng-repeat-end
 - load partial view						ng-include
 - conditionally display elements			ng-switch
 - hide inline telmplate expr while AngJS is processing content (???)	ng-cloak
 
* Data Binding Directives
 (All can be applies as attribute or class)
 ng-bind			binds innerText property of HTML element
 ng-bind-html		binds innerHTML property of HTML element (can be dangerous?)
 ng-bind-template	same as ng-bind but allows for mult template expressions in the attribute value (?)
 ng-model			creates two-way data binding (applicable to input, textarea & select elements)
 nd-non-bindable	declares region where no data binding will be performed
 
	Applying as attribute:
 	There are <span ng-bind="todos.length"></span> items
 	Applying as class:
 	There are <span class="ng-bind: todos.length"></span> items

* Template Directives
 	Used to generate HTML elements using templates, good for working with collectoins
 (Application: A - attribute, C - class, E - element)
 ng-cloak			A,C		applies CSS style that hides inline binging expressions
 ng-include			E,A,C	loads, processes and inserts an HTML fragment into the DOM
 ng-repeat			A,C		generates copies of single element for each object in array or properto on object
 ng-repeat-start	A,C		start of repeating section with multiple top-level elements
 ng-end				A,C		end of repeating section with multiple top-level elements
 ng-switch			E,A		changes elements in the DOM based on value of data bindings
 
* ng-repeat
 - ng-repeat can be used to iterate through items in array, or properties in object
 - ng-repeat can also work with key/value pairs (props: propname/propvalue, arrays: index/value)
 	<tr ng-repeat="item in collection">
 		<td ng-repeat=(key,value) in item">
 			{{key}}={{value}}
 		</td>
 	</tr>
 - has built-in variables:
 $index		position of current item or property
 $first		true if current item is first in collection
 $middle	true if current item is neither first nor last in collection
 $last		true if current item is last in collection
 $even		true for even-numbered items in collection
 $odd		true for odd-numbered items in collection
 
* ng-repeat-start and ng-repeat-end
  - allow for multiple top-level elements to be repeated for each item in collection, e.g., table rows <tr>
  - the start and end directives act like opening and closing braces that enclose all elements to be generated for a single item
 
* ng-include
  - adds content from a separate HTML file to the main file's DOM
  - useful for partial views
  - 3 configuration params:
  	src			src="'filename'"	<- notice single quotes inside double quotes!
  	onload		expression to evaluate when content is loaded
  	autoscroll	scroll the viewport when content is loaded

	ex: as element:
		<ng-include src="viewFile()" onload="reportChange()"></ng-include>
		as attribute:
		<div ng-include="viewFile()" onload="reportChange()"></div> 	

* ng-switch
  - allows for conditionally displaying partial views for multiple cases
    ex: <div ng-switch on="data.mode">
			<div ng-switch-when="Table">
				<ng-include src="'views/table.html'"></ng-include>
			</div>
			<div ng-switch-when="List">
				<ng-include src="'views/list.html'"></ng-include>
			</div>
			<div ng-switch-default>
				Select table or list to display data 
			</div>
		</div>
		
* ng-cloak
  - used as attribute for elements that have inline bingdings, to prevent {{...}} from showing on screen when content is loaded
  - not a problem on fast browsers
  
CHAPTER 11
Using Element and Event Directives

* More directives:
  - show or hide elements						ng-show, ng_hide
  - remove elements from DOM					ng-if
  - avoid transclusion problem when generating	ng-repeat
    elements that can't have intermediate
    parent element (???)
  - assign elements to classes or				ng-class or ng-style
    set individual CSS style properties
  - assign different classes to odd/even		ng-class-odd, ng-class-even
    elements from ng-repeat
  - define behavior for event					event directive (e.g., ng-click)
  - handle event for which AngularJS			custom event directive
    does not provide directive
  - apple boolean attibutes to elements			boolean attribute directive (e.g., ng-checked)
  
* Element directives:
ng-if			A		adds & removes elements from DOM
ng-class		A,C		sets class attribute for element
ng-class-even	A,C		sets class attr for even-numbered elems from ng-repeat
ng-class-odd	A,C		sets class attr for even-numbered elems from ng-repeat
ng-hide			A,C		shows/hides elements in the DOM
ng-show			A,C		shows/hides elements in the DOM
ng-style		A,C		sets one or more CSS properties

* ng-show/ng-hide
  - only hide elements
  - can be used with ng-repeat, BUT
  - if stuff hidden - row indexing & striping in tables don't work correctly
  
* ng-if
  - syntax: ng-if="condition", if condition is true - element is removed from DOM
  - cannot be used for the same element with ng-repeat (transclusion - they both try to modify child element and AngJS doesn't know how to handle it)
    > possible solution - use filter:
      <tr ng-repeat="item in todos | fiter: {complete: 'false'}">...</tr>
      
* Classes & CSS Styles
  - ng-class -> assign elements to classes
    ex: <tr ng-repeat="item in todos" ng-class="settings.Rows">
  - ng-style - set individual CSS properties
    ex: <td ng-style="{'background-color': settings.Columns}">
  - similar applications; prefer ng-class -> changes applied automatically

* Odd & Even Classes
  - ng-class-odd / ng-class-even
  - similar to using $odd and $even built-in ng-repeat variables
  
* Event Directives
  - specify custom behavior when different HTML events are triggered
  - all can be used as attribute or class
  ng-blur			'blur' event (when element loses focus)
  ng-change			'change' event (when element's state of content changes (checkbox is checked, text in input element edited, ...)
  ng-click			'click' event (user clicks a mouse/pointer)
  ng-copy			'copy" event
  ng-cut			'cut' event
  ng-paste			'paste' event
  ng-dblclick		'dblclick' event (when user double-clicks mouse/pointer)
  ng-focus			'focus' event (when element gains focus)
  ng-keydown		3 key events
  ng-keypress		...
  ng-keyup			...
  ng-mousedown		6 mpose/pointer events
  ng-mouseenter		...
  ng-mouseleave		...
  ng-mouseemove		...
  ng-mouseover		...
  ng-mouseup		...
  ng-submit			'submit' event (when a form is submitted)
  
* invoked:
  - inline (OK to use if simple):
    <button class="btn btn-info" ng-click="data.rowColor = button">
  - by calling controller function (preferred):
    $scope.handleEvent = function(e){
    			console.log("Event type: " + e.type);
    			$scope.data.columnColor = e.type == "mouseover" ? "Green" : "Blue";
    			console.log("Column color: " + $scope.data.columnColor);
    };
    (...)
    <tr ng-repeat="item in todos" ng-class="data.rowColor"
				ng-mouseenter="handleEvent($event)">
				
* custom directives can be created for events that AngularJS does nor provide handlers (e.g., touchstart, touchend)

* boolean attribute directives
  - some issues with assigning values to them (not sure why?
    e.g., disabled attribute cannot be wet to false to enable an element, like a button (???)
    the directives solve this problem
  - these directives can only be used as attributes:
  
  ng-checked		manages 'checked' attr (used on 'input' elements)
  ng-disabled		manages 'disabled' attr (input & button)
  ng-open			manages 'open' attribute (details)
  ng-readonly		manages 'readonly' (input)
  ng-selected		manages 'selected' (option)

* directives for managing other attributes
  (can only be used as attributes)
ng-href			sets href attr on 'a' elements
ng-src			sets img attr on 'img' elements
ng-srcset  		sets srcset attr on 'img' elements (new in HTML5, for setting multiple images depending os display size/resolution)

CHAPTER 12
Working with Forms

* Form-related directives:
  - create 2-way model binding				ng-model
  - validate form elements					add 'form' element to document and apply 'novalidate" attr;
  											use special vars ($valid) to assess validity of elements or entire form
  - visual feedback on validation			AngularJS validation CSS classes (??)
  - provide text validation cues			special validation vars ($valid), with other directives like ng-show
  - defer validation feedback				add variable that latches validation feedback (??)
  - complex validation on 'input' elems		use additional AngularJS attrs (??)
  - sontrol value of model property when using check box		ng-true-value/ng-false-value (attrs)
  - validate 'textarea' element				use additional AngularJS attrs (??)
  - generate 'option' elems for 'select' elem		ng-options (attr)
  
* Using form elems with 2-way data bindings
  ex: <td>
		<input type="checkbox" ng-model="item.complete" />
	  </td>

  - Implicitly creating model properties
    > can use 2-way data bindings for that
	> when you retrieve or assign value to nonexistent object or property -> no errors; AngJS will create
	  an 'implicitly defined' property or object.
	 ex: <div class="form-group row">
			<label for="actionText">Action:</label>
			<input id="actionText" class=form-control" ng-model="newTodo.action">	<-- text input
		 </div>
		 <div class="form-group row">
			<label for="actionLocation">Location:</label>
			<select id="actionLocation" class="form-control" ng-model="newTodo.location">	<-- drop-down list
				<option>Home</option>
				<option>Office</option>
				<option>Mall</option>
			</select>
		 </div>
	> sometimes can get an error:
	  TypeError: Cannot read property 'action' of undefined
	  if form controls (input, select) have not been modified (because the objects will not be defined).
	  To avoid: check that they exist using angular.isdefined method.

* Validating forms
  - form element is not required for 2-way binding, but it IS required for validation
  - form element's 'novalidate' attribute disables browser validation and enables AngularJS validation features
  - specify element's 'name' attribute if want to vlidate
  - specify 'type' attribute to tell what kind of element it is (it will imply type of validation)
    HTML5 'type' attribute values that AngJS can validate:
    checkbox		checkbox (pre-HTML5)
    email			text input that accepts e-mail addreses (new in HTML5)
    number			text input that accepts number (new in HTML5)
    radio			radio button (pre-HTML5)
    text			standard text input for any value (pre-HTML5)
    url				text input that accepts URL (new in HTML5)
  - use 'required' attr to tell the form value must be supplied
  - monitoring validity of form
    > with validation variables:
    $pristine		true if no user interaction
    $dirty			true if user has interacted w/form
    $valid			true if contents are valid
    $invalid		true if contents are invalid
    $error			details of validation errors
    
* Form validation feedback
  - has classes that can be combined with CSS to provide feedback bystyling elements
    ng-pristine		elements not touched by user are added to this class
    ng-dirty		elements that user interacted with are added here
    ng-valid		valid elements are in this class
    ng-invalid		invalid elements go here
  - elements added/removed to/from classes after every interaction
  - ex:
    <style>
    	form .ng-invalid.ng-dirty {background-color: lightpink;}
    	form .ng-valid.ng-dirty {background-color: lightgreen;}
    	span.summary.ng-invalid {color: red; font-weight: bold;}
    	span.summary.ng-valid {color: green;}
    </style>
    
* Feedback for cpecific validation constraints
  - similar to above, with more specific classes:
  		form .ng-invalid-required.ng-dirty {background-color: lightpink;}
    	form .ng-invalid-email.ng-dirty {background-color: lightgoldenrodyellow;}
  - use carefully to mot produce conflicting results for different constraints

* Using the Special Variables to provide feedback
  - here, $error with ng-show directive; $error hasproperties for all constraints applied to element (email & required)
  ex: <div class="error" ng-show="myForm.userEmail.$invalid && myForm.userEmail.$dirty">
		<span ng-show="myForm.userEmail.$error.email">
			Please enter a valid e-mail address
		</span>
		<span ng-show="myForm.userEmail.$error.required">
			Please enter your e-mail address
		</span>
	  </div>
	  
* Reducing the number of feedback elements
  - generate feedback in a controller function:
  			$scope.getError = function(error){
    			if (angular.isDefined(error)){
    				if (error.required){
    					return "Please enter a value";
    				} else if (error.email){
    					return "Please enter a valid e-mail address";
    				}    				
    			}
    		}
  - call when checking for errors:
  		<div class="error" ng-show="myForm.userEmail.$invalid && myForm.userEmail.$dirty">
			{{getError(myForm.userEmail.$error)}}
		</div>
		
* Deferring validation feedback
  - can defer until form submitted, define & use $scope property 'showValidation' and show conditionally with ng-show
  
* Using form directive attributes
  - "replace" (?) standard form elements such as 'form', 'input', 'select'
  - support optional attributes to integrate with AngJS
  - attributes for 'input' elements
  	can only be used if 'type' attr not specified, or if 'type' is text, url, email or number
  	ng-model		two-way model binding
  	ng-change		provides expression evaluated when element contents change
  	ng-minlength	min # of chars required for element to be valid
  	ng-maxlength	max ...
  	ng-pattern		sets regex that the element's contents must match
  	ng-required		sets value of 'required' attr with a data binding (?)
  	> ex: <div class="form-group">
			<label>Text:</label>
			<input name="sample" class="form-control" ng-model="inputValue"
				ng-required="requireValue" ng-minlength="3"
				ng-maxlength="10" ng-pattern="matchPattern">
	      </div>
  	> don't use ng-pattern when type is url, email or number - AngJS sets it itself!!!
  - attributes for type="checkbox'
    ng-model		two-way binding
    ng-change		provides expression evaluated when element contents change
    ng-true-value	value that the model binging expr will be set to when checked
    ng-false-value	value that the model binging expr will be set to when unchecked
    > ex: <label>
			<input name="sample1" type="checkbox" ng-model="inputValue1" 
				ng-true-value="'Hurrah!'" ng-false-value="'Boo!'">
			This is a checkbox 
		  </label>
  - attributes for 'textarea' elements
    same as for 'input' element
    > ex: <div class="form-group">
			<textarea name="sample" cols="40" rows="3" ng-model="textValue"
				ng-required="requireValue" ng-minlength="3"
				ng-maxlength="10" ng-pattern="matchPattern">
	      </div>
  - using 'select' elements
    important: ng-options
    > format: <label> for <variable> in <array>
    > ex: <select ng-model="selectValue" ng-options="item.action for item in todos"></select>
    > to define option for undefined use 'option' element:
    	<select ng-model="selectValue" ng-options="item.action for item in todos">
			<option value="">(Pick one)</option>
		</select>
    > to change the selection value (instead of entire item) - use format:
    	<selected property> as <label> for <variable> in <array>
      ex: <select ng-model="selectValue" ng-options="item.id as item.action for item in todos">
			<option value="">(Pick one)</option>
		  </select>
	> creating optgroup elements (aka grouping options in drop-down by item's property) - use format:
		<label> group by <property> for <variable> in <array>
	  ex: <select ng-model="selectValue" ng-options="item.action group by item.place for item in todos">
			<option value="">(Pick one)</option>
		  </select>

CHAPTER 13
Using Controllers and Scopes

* Summary
  - create a controller				Module.controller method (to define), ng-controller directive (to apply to HTML element)
  - add data & behavior to scope	declare dependency on $scope service, create (assign) properties in controller factory fn
  - create monolithic controller	apply ng-controller dir to 'body' elem, use factory fn to define data and behavior
  - reuse a controller				apply ng-controller dir to multiple HTML elems
  - communicate between controllers	send events via the root scope or via service
  - inherit behavior and data
    from another controller
  - create controllers w/o scopes	use scopeless controllers (?)
  - notify scope about change		use $apply, $watch & $watchCollection methods to inject changes into scope, or monitor scope for changes
  
* Controller = link between domain model and view
  - cannot have AngJS application without one, but can have multiple
  - Provide data and logic to views through 'scopes'

* To create: 
  .controller('ctrl_name', functon($scope){
  	[ctrl code]
  });
  - the function is the constructor, aka 'factory fn'
  - usually uses '$scope' as argument (dependency injection)
* To apply to element: use ng-controller="ctrl_name" directive as attribute
  ex: <div class="well" ng-controller="simpleCtrl">
* To use: define scope's data and/or behaviors (= JS functions that can be called fron the view)
  ex: $scope.city = "London";
      $scope.getCountry = function(city){...}
* To modify the scope: use input elements, like <select> and bind with ng-model to scope's property
  ex: [in controller: $scope.cities = ["London", "New York", "Paris"];]
  	  [in HTML/body:]
  	  <div class="well">
		<label>Select a city:</label>
		<select ng-options="city for city in cities" ng-model="city"></select>
	  </div>
  (Notice interesting way of using ng-options: "city for city in cities")
* Organizing controllers:
  - monolithic controller = use ng-controller on the <body> element
    > simple, no need for communication between controllers
    > effectively implies one view for entire application
    > good for small applications, but not for complex ones
  - reusing controllers
    > can reuse the same ctrl with several views in application
    > each "instance" will have its own scope
    > allows different views present the same data in different ways
* Communicating between scopes
  - use root scope ($rootScope) - available as a service, can be an arg (dependency) in controller function
  - $scope methods for events:
    $broadcast(name, args)		sends event from current scope to all child scopes
    							name - event name, args - event data
    $emit(name, args)			sends event from current scope up to root scope
    $on(name, handler)			registerd event handler to invoke when specified event is received
  - can also use Service -> it will be dependent on $rootScope and colltroller(s) will depend on the service
    (code reusability / clarity)
* Controller inheritance
  - How to do:
    > use ng-controller directive to apply controller1 to an element
    > use ng-controller directive to apply controller2 to its sub-element
    > controller2 will inherit from controller1 (controller1 == parent, controller2 == child)
  - Functions/data defined in "parent" controller are inherited by "child"
  - Child can override a function or add a function
  - Data inheritance:
  	> Using "plain data":
  	  $scope.data = "Hello, Adam";
  	  will cause duplication of data for child controllers (child will end up with its own copy of the scope data).
  	  Then bind/refer to it like this: ng-model="data", $scope.data
  	> Using objects as scope data:
  	  $scope.data = {dataValue: "Hello, Adam"};
  	  will cause only one copy of the data (object).
  	  Then bind/refer to it like this: ng-model="data.dataValue", $scope.data.dataValue
  	> Can serve both scenarios (sometimes useful)
  	> Caused by "prototype inheritance" in JS (??)
* Scopeless controllers
  - new in AngularJS
  - To create: use ng-controller="[controller-to-apply] as [variable-name]" as element attribute
    ex: <div class="well" ng-controller="simpleCtrl as ctrl">
  - to use: refer to it by the variable-name:
  	ex: <input class="form-control" ng-model="ctrl.dataValue">
  - in controller function definition:
    > don't declare $scope as arg
    > use "this" to create data/methods
      ex: this.dataValue = "Hello, Adam";
    	  this.reverseText = function(){
    			this.dataValue = this.dataValue.split("").reverse().join("");
    	  }
* Explicitly updating the scope
  - useful when need to use AngularJS with other frameworks (like jQuery)
  - 3 $scope methods:
    $apply(expression)					applies a change to the scope
    $watch(expression, handler)			registers a handler to call when 'expression' value changes
    $watchCollection(object, handler)	registers a handler to call when any props of "object" change

CHAPTER 14
Using Filters

* To format or sort data, without modifying the original data in the scope
* How to use:
  Single-value filters:
  - format currency value				'currency' filter
  - format general numeric value		'number' filter
  - format date							'date' filter
  - change case of string				'uppercase' / 'lowercase' filter
  - generate JSON representation of JS object	'json' filter
  Localizing filter output:
  - localize formatting produced by		add angularjs localization file to HTML doc via 'script'
    currency, number or date filter
  Collection filters:
  - select limited # of objects from array		'limitTo' filter
  - select objects in array				'filter' filter
  - sort objects in array				'orderBy' filter
  Misc/advanced:
  - combine multiple filters			use filter chaining
  - create custom filter				use Module.filter to specify factory fn that generates worker fn
  										that will perform data formatting or transformation
  - create filter that uses other filters		declare dependencyon $filter service in custom
  												filter factory fn, use the service to invoke desired filters
* 'currency' filter:
  - to use: ... | currency
  - ex: <td class="text-right">{{p.price | currency}}</td>
  - ex with currency symbol: <td class="text-right">{{p.price | currency:"PLN"}}</td>
* 'number' filter
  - to use: ... | number[:options]
  - ex: <td class="text-right">${{p.price | number:0}}</td> <-- will display with no decimals
* 'date' filter
  - to use: ... | date[:"date-format-string"]
  - formatting:
  yyyy		4-digit year
  yy		2-digit year
  MMMM		full month name (January)
  MMM		short month name (Jan)
  MM		2-digit month
  M			1- or 2-digit month
  dd		2-digit day
  d			1- or 2-digit day
  EEEE		full name of day (Tuesday)
  EEE		short name of day (Tue)
  HH		hour, 2-digit, 24h clock
  H			hour, 1- or 2-digit, 24h clock
  hh		hour, 2-digit, 12h clock
  h			hour, 1- or 2-digit, 12h clock
  mm		minutes, 2-digit
  m			monutes, 1- or 2-digit
  ss		seconds, 2-digit
  s			seconds, 1- or 2-digit
  a			am/pm marker
  Z			4-char repsesentation of time zone
  -----
  medium		MMM d, y h:mm:ss a
  short			M/d/yy h:mm a
  fullDate		EEEE, mmmm d,y
  longDate		MMMM d, y
  mediumDate	mmm d, y
  shortDate		M/d/yy
  mediumTime	h:mm:ss a
  shortTime		h:mm a
  
* 'uppercase' / 'lowercase' filter
  - to use: ... | uppercase
* 'json' filter
  - to use: ... | json
  - produces JSON output for JS object, e.g.:
    {"name": "Apples", "category": "Fruit", "price": 1.2, "expiry": 10}
* Localizing filter output:
  - add localizing script in <head> section:
    <script src="angular-locale_fr-fr.js"></script>
* 'limitTo' filter
  - to use: ... | limitTo:[number-expr]
  - ex: <tr ng-repeat="p in products | limitTo:limitVal">
  - if limitVal is < 0 --> will show the LAST limitVal elements in collection
* 'filter' filter
  - to use: ... | filter:{prop-name: prop-value}
  - ex: <tr ng-repeat="p in products | filter:{category: 'Fish'} ">
  - or, using a function:
    			$scope.selectItems = function(item){
                	return item.category == "Fish" || item.name == "Beer";
                }
    	(...)
   		<tr ng-repeat="p in products | filter:selectItems ">
* 'orderBy' filter
  - to use: ... | orderBy: 'prop-name'
  - ex: <tr ng-repeat="p in products | orderBy:'price'">
  - for property name, use single quotes; if not used - will assume a scope variable and fail if not defined
  - order: ascending by default. + asc, - desc, ex: orderBy:'-price'
  - or, using a function:
  	<tr ng-repeat="p in products | orderBy:customSorter">
  - or by multiple criteria:
    <tr ng-repeat="p in products | orderBy:[customSorter, '-price']">
* chaining filters
  - combining filters together
  - how: use |, e.g.: <!--  <tr ng-repeat="p in products | filter:selectItems | orderBy:'-price'">
* to call a filter in JS (system or custom), e.g., when combining functionality:
  $filter("skip")(data, args for 'skip' filter)
  $filter("limitTo")(data, count)
* to apply filter with arguments - use ':'
  - ex: <tr ng-repeat="p in products | take:3:5">
  	> used a 'take' custom filter with 2 args, 3 & 5