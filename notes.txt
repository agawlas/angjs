CHAPTER 2:

Creating a Controller:

in <script>:
(previously defined:
var todoApp = angular.module("todoApp", []);
)

todoApp.controller("ToDoCtrl", function($scope){
	$scope.todo = model;
});

in <body>:
<body ng-controller="ToDoCtrl">

* $ used in built-in features of AngularJS; usually a service that provides features to multiple controllers
* $scope - used to expose data and functionality to views
* $scope.todo - defines a todo property on the $scope service object
* adding ng-controller attribute to the <body> tag means that the controller will be responsible for that entire section of HTML

Creating a View:

* can use data binding: double-braces {{...}}, e.g., todo.user, todo.items, ...
* access limited to $scope
* expressions can be used in data bindings ({{todo.items.length}}; avoid complicated expressions, put that logic in the controller instead

* ng-repeat (aka repeater) is a "directive" to iterate through a set of objects, e.g.:
				<tr ng-repeat="item in todo.items">
					<td>{{item.action}}</td>
					<td><input type="checkbox" ng-model="item.done" /></td>
					<td>{{item.done}}</td>
				</tr>
				
* ng-model provides two-way model binding: values changed by user are stored in the model:
 	<td><input type="checkbox" ng-model="item.done" /></td>
 
 Creating and Using Controller Behaviors:
 
 * behaviors - controller functions that operate on the data model to implement the business logic of the application
 * e.g., can calculate something for custom-display in the view (incompleteCount)
 * angular.forEach(list, [action]) - enumerator of elements in a list
 
 * ng-hide - one of directives to manipulate the browser DOM based on the state of AngulasJS model (hide the label if expr is true)
 
 * behaviors can depend on other behaviors (call them inside their body?)
 
 * ng-class - another AngularJS directive to apply CSS class to a control(?)
 * can use multiple directives in one <span> (e.g., ng-class, ng-hide)
  
Responding to User Interaction:

* via behaviors and directives
* ng-model directive can add a new (dynamic) property that has not been defined before, for user interaction
* ng-click sets up event handler (using behavior function) for click action

Filtering and Ordering Model Data:

Ex: <tr ng-repeat="item in todo.items | filter: {done: false} | orderBy: 'action'">
* filter: {criteria} - selects items for which criteria are met (e.g., {done: false})
* orderBy: property - order items by property values, ascending (if property is not defined by the scope, must use string literal: 'property')

* Better filtering: filter method of AngularJS model object
	- used to create a filter factory which returns a function that is used to filter a set of data objects.
	- aka, using the filter method requires passing in a function that returns a function that returns the filtered data

>> DON'T UNDERSTAND how the items are passed in with the syntax:
	<tr ng-repeat="item in todo.items | checkedItems:showComplete | orderBy: 'action'">

Getting the Data via Ajax:

* run - method defined in AngularJS module object; takes a function that is executed once AngularJS has performed its initial setup
* $http as argument - tells AngularJS to use the $http service (dependency injection)
* $http - service that provides access to low-level Ajax requests
* $http.get - method to make HTTP GET request (RESTful interface?) to the server for the JSON file
	$http.get("todo.json").success(function(data){
				model.items = data;
	});
	- get - returns a 'promise' - will come in the future when completed
	- [promise].success - takes a function invoked when request completed; data -> JSON stuff parsed and turned into a JavaScript object
	- that JS object ('data') is assigned to model.items

CHAPTER 3

* 2 kinds of Web applications: round-trip & single-page
* round-trip:
	- whole page submitted at once
	- user action would cause the page to fully reload (sent a completely new HTML doc)
	- logic and data reside on the server
	- still a lot of them around: require very little from browser -> widest client support
	- flaws:
		>> user waits while HTML doc requested & loaded
		>> large server infrastructure to process requests & manage state
		>> require a lot of bandwidth
* single-page:
	- initial HTML doc sent once to browser, never reloaded or replaced
	- user interactions cause Ajax requests for smaller HTML fragments or data
* AngularJs better suited for s-p applications, and complex r-t applications (jQuery good for r-t & simpler)
* jQuery:
	- explicitly manipulate browser's DOM
	- fluid API (?)
	- core library easy to extend
* AngularJS:
	- builds on the core functionality of jQuery (contains a cut-down version jqLite)
	- drawback: up-front investment before you see results
	- AngularJS is a client-side MVC framework	

Model (in MVC):
* data that users work with
* view models - represent just data passed from controller to view
* domain models - contain data in a business domain, with all operations, transformations and rules for CREATING, STORING & MANIPULATING that data (aka model logic)
* CRUD -> Create, Read, Updare & Delete operations

Controller (in MVC):
* conduit between model & view(s)
* adds business domain logic (aka 'behaviors') to model's 'scopes'
* able to initiate, present data from & update (based on user interactions) scope
* can create 'view data' (aka 'view model data' aka 'view models')
	- simplify the definition of views
	- non-persistent
	- usually created and accessed via controller's scope
	
View (in MVC):
* contain the logic & markup to present data to user
* should NOT contain complex logic (belongs in controller)
* should NOT contain logic that creates, stores or manipulates the domain model

RESTful Service:
* web service that provides CRUD functionality
* operations expressed through a combination of URL & HTTP method
* Methods:
	- GET - Retrieves the data object specified by the URL
	- PUT - Updates ...
	- POST - Creates a new data object
	- DELETE - Deletes ...
	
To avoid putting logic in the wrong place:
* View logic should prepare data only for display and never modify the model
* Controller logic should never directly create, update or delete data from the model
* The client should never directly access the data store
 
CHAPTER 4
HTML and Bootstrap CSS Primer

HTML Document Structure:
<!DOCTYPE html>
<html>
	<head>
		... head content (metadata)
	</head>
	<body>
		... body content
	</body>
</html>

Other elements:

button - button, for user interaction
div - generic element; adds structure
h1 - top-level header
input - field to get a single data item from user
link - imports content to html
	ex: <link href="bootstrap.css" rel="stylesheet" />
	attributes: href - content to import, rel - content type
script - script to be executed as part of the document (typically JS)
span - generic element; adds structure
style - region of CSS settings
table - table (rows & columns)
tbody - table body
td - table data (cell)
th - header cell in a table row
thead - table header
tr - table row
title - document title, used for window/tab title in the browser

BOOTSTRAP
Basic Bootstrap Classes:

panel - panel with a rounded border. Can have header and footer.
panel-heading - heading for a panel
btn - button
	ex: <button class="btn">Basic Button</button>
well - groups elements with an inset effect

Content & Size Classes (used with basic class, e.g., btn)

* btn-primary, btn-success, btn-warning, btn-info, btn-danger
* btn-large, btn-small
* btn-block - fits available horizontal space
ex: <button class="btn btn-block btn-warning">Standard Block Warning</button>

Table Styles:

table - basic table styling
table-striped - alternate row striping
table-hover - different row style when a mouse hovers over a row
table-condensed - reduced spacing (more compact layout)

* content styling can be applied to rows or even cells:
	<tr class="success"><td>United Kingdom</td><td>London</td></tr>
	<tr class="danger"><td>France</td><td>Paris</td></tr>
	<tr><td>Spain</td><td class="warning">Madrid</td></tr>

Forms in Bootstrap:

* form-group - groups elements together, e.g., label & input box (form-control):
	<div class="form-group">
		<label>Name:</label>
		<input name="name" class="form-control" />
	</div>
* form-control - input field like a textbox
* radio - radio button (not sure if this is Bootstrap or generic)
	ex: <div class="radio">
			<label>
				<input type="radio" name="junkmail" value="yes" checked />
				Yes, send me endless junk mail
			</label>
		</div>
		<div class="radio">
			<label>
				<input type="radio" name="junkmail" value="no" />
				No, I never want to hear from you again
			</label>
		</div>
	Q: Does the same name ("junkmail") put them in the same group and mutually exclusive?
* checkbox - checkbox (not sure if this is Bootstrap or generic)
	ex: <div class="checkbox">
			<label>
				<input type="checkbox" />
				I agree to terms and conditions.
			</label>
		</div>
		
Grids in Bootstrap:

* based on 12-column rows
* assign "width" to columns like this: <div class="col-xs-1">column content</div>
* ex:
		<div id="gridContainer">
			<div class="row grid-row">
				<div class="col-xs-12">aaa</div>
			</div>
			<div class="row grid-row">
				<div class="col-xs-6">bbb</div>
				<div class="col-xs-6">ccc</div>
			</div>
		</div>
* sometimes grids impossible to render properly in browser (if no support for CSS3); then ok to use tables.

Responsive Grids:

* stack grid cells vertically if screen width < xxx pxls.
* use these Bootstrap classes:
	- col-sm-* - vert if screen width <= 768 px
	- col-md-* - 940 px
	- col-lg-* - 1170 px
* need a "meta" tag to tell mobile browsers to display the content actual size:
	<meta name="viewport" content="width=device-width, initial-scale=1">
	
CHAPTER 5
JS primer

* angular.isFunction(obj) - checks if ob is a function
	angular is a global object created automatically when angular.js is added to HTML:
	<script src="angular.js"></script>

* vars declared in script (not inside a function) are global and can be accessed anywhere, including other scripts within the same HTML doc.
	- don't use global vars!

* AngularJS utility methods for string:
	- angular.isString(object)
	- angular.lowercase(string)
	- angular.uppercase(string)

* Creating objects:
	- with 'new':
		var obj = new Object();
		obj.name = "Adam";
		obj.weather = "sunny";
		
	- with object litersl:
		var obj = {
			name: "Adam",
			weather: "sunny"
		};
	-> object properties can be added AFTER object is created!
	-> accessing properties:
		- obj.name, obj.weather
		- obj["name"], obj["weather"]
		- var prop = "weather"; obj[prop] = ...
	-> checking for properties - use 'in':
		var hasName = "name" in obj; 

* Adding functions to objects:
	var obj = {
		name: "Adam",
		weather: "sunny",
		printMessages: function(){
			console.log("Hello " + this.name + ".");
			console.log("Today is " + this.weather + ".");
		};
	};
	obj.printMessages();
	-> to access object's properties from within a function, use 'this.'!
	
* Extending objects:
	copies all the 'base' object's properties to the extended object
	var obj = {
		name: "Adam",
		weather: "sunny",
		printMessages: function(){
			console.log("Hello " + this.name + ".");
			console.log("Today is " + this.weather + ".");
		};
	};
	var extObj = {
		city: "London"
	};
	angular.extend(extObj, obj);	// now extObj has name, weather and printMessages, too!
	-> angular.extend preserves all properties and methods of the target object (extObj)
	-> angular.copy creates a copy of original object (obj) without preserving target's props
	
* Detecting objects: angular.isObject(arg)
	-> returns false for functions
	
* Enumerating properties:
	for (var prop in obj){
		console.log("Name: " + prop + " Value: " + obj[prop]);
	}
	
	or, with AngularJS:
	angular.foreach(obj, function(value, key){
		console.log("Name: " + key + " Value: " + value); 
	});
	-> will produce the same result!
	-> will include functions in a=enumeration!

* Adding/deleting object properties:
	- add - just use it:
	obj.newProp = "aaa";
	(or obj["newProp"] = "aaa";
	obj.sanHello = function(){
		console.write("Hello");
	};
	- delete - use 'delete':
	delete obj.newProp;
	delete obj["name"];
	delete obj.sayHello;
	
* string concatenation (+) has higher precedence than addition (+):
	var one = 5 + 5;	-> 10
	var two = 5 + "5";	-> 55
	
* Converting numbers to strings:
	- (5).toString()	-> base 10
	- String(5)
	Also these are available:
	- toString(2), toString(8),...
	- toFixed(n)	- real number with n decimal digits
	- toExponential(n) - number in exp form, 1 digit before the decimal point & n digits after
	- toPrecision(n) - number with n significant digits, using exp notation if needed

* Converting strings to numbers:
	- Number(str)
	- parseInt(str)
	- parseFloat(str)
	
* Arrays:
	- create:	var arr = new Array();// or var arr = [];
				arr[0] = 100;
				arr[1] = "aaa";
				arr[2] = false;
		or use array literal:
			var arr = [100, "aaa", false];
	- detect: angular.isArray(arg)
	- enumerating:
		for (var i=0; i < arr.length; i++){
			console.log("Index: " + i + ": " + arr[i]);
		}
		OR:
		angular.foreach(arr, function(value, key){
			console.log(key + ": " + value);
		});
		-> in this case, key is not necessaily an "index", e.g., if the array has holes (?)
	- built-in methods:
		> concat(anotherArray) returns concatenated Array
		> join(separator) returns string of separator-delimited array elements
		> pop() removes last item from array and returns it
		> push(item) appends item to array
		> reverse() reverses the array (in place!)
		> shift() removes first object from array and returns it
		> slice(start,end) returns a section of array
			start, end indexed from 0;
			start included, end excluded
		> sort() (in place!)
		> splice(index,count) removes count items from array, starting at index
		> upshift(item) inserts item at the start of array

* null & undefined:
	- not the same (undefined is a type, null is a value)
	- both falsy 
	- checking if something is null or undefined (don't care which):
		if (!obj.prop)
	- for undefined -> angular.isDefined / angular.isUndefined

* Promises:
	- promise - represents an item of work that will be performed asynchronously and completed in the future
	- most common - when making Ajax requests
	- promise is used to notify the application when the request has completed
	- 	var promise = $http.get("todo.json");
		promise.success(function(data){
			$scope.todos = data;
		});
	- promise object has 3 methods:
		> success(callback) - callback invoked when work was successful; receives returned data
		> error(callback) - callback invoked when work could not be completed; receives problem details
		> then(success, error) - callbacks for success and failure
		
* JSON (JavaScript Object Notation)
	- data format for web apps
	- supported types: String, Nymber, Boolean, ARray, Object, null
	- AngularJS support: angular.toJson, angular.fromJson
	- ex:	var myApp = angular.module("demo", []);
			myApp.controller("demoCtrl", function($scope, $http){
				var jsonStr = angular.toJson(data);
				console.log(jsonStr);
				$scope.todos = angular.fromJson(jsonStr);
			});
